<?xml version="1.0" encoding="UTF-8"?>

<!-- Part of the open-source Proximity system (see LICENSE for
     copyright and license information).
-->

<!DOCTYPE glossary PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
          "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<glossary>

<glossentry>
<glossterm>accuracy</glossterm>
<glossdef>
<para>Accuracy measures the percentage of test instances correctly
      classified by the model. More specifically, it computes
      TP/(TP+FP) where TP = true positives and FP = false positives.</para>
</glossdef>
</glossentry>

<glossentry>
  <glossterm>adjacency</glossterm>
  <glossdef>
    <para>Two query vertices are adjacent if they are connected by a
    directed or undirected edge; a query vertex is adjacent to the
    edges that connect it to other vertices.</para>
  </glossdef>
</glossentry>

<glossentry>
<glossterm>aggregation</glossterm>
<glossdef>
<para>Aggregation is the process of grouping data.  For example, in
      Proximity the models aggregate attribute values to create
      features. Example aggregation functions include average, count,
      degree, and proportion.</para>
</glossdef>
</glossentry>

<glossentry>
  <glossterm>ambiguous</glossterm>
  <glossdef>
    <para>A query is ambiguous if it admits more than one
    interpretation.  For example, a query with adjacent annotated
    vertices is ambiguous because neither annotation takes precedence
    over the other.  Ambiguous queries are not permitted in
    QGraph.</para>
  </glossdef>
</glossentry>

<glossentry id="gloss_auc">
  <glossterm>area under the ROC curve</glossterm>
  <acronym>AUC</acronym>
  <glossdef>
    <para>Area under the ROC (receiver operating characteristic)
          curve evaluates the accuracy of a ranking of all test
          instances according to their estimated probabilities. AUC
          lets you more easily compare one model to another, independent
          of error cost and without requiring that the prior class
          distribution be known.  An AUC value of 0.5 indicates
          chance performance; values approach 1.0 as performance
          improves.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>attribute</glossterm>
  <glossdef>
    <para>An attribute is a name-value pair that represents additional
    information about the database entity on which it appears.
    Proximity attribute values are sets, which may contain 
    zero or more values and which may include specific values more than once.  
    Proximity supports attributes for objects, links, subgraphs, and
    containers.
    Objects and links can have a variable number of attributes
    and attributes can have a variable number of values.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>attribute constraint</glossterm>
  <glossdef>
    <para>Attribute constraints compare the attribute values of two
    database entities, such as two objects or two links.
    <!-- Proximity currently requires that attribute
    constraints only compare two objects or two edges; mixing vertices
    and edges is not permitted.  Attribute constraints can be used to
    compare different attributes as long as their data types are
    compatible.  Additional restrictions apply to using constraints to
    compare annotated elements or elements that cross subquery
    boundaries.  Only one of the items being compared may be
    annotated, and in the case of comparing edges, the annotated edge
    must be optional. -->
    </para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>attribute value condition</glossterm>
  <glossdef>
    <para>Attribute value conditions restrict query matches
    to objects or links having the attribute value specified in the
    condition.
    <!-- Values can be ranges (e.g., an object can satisfy a condition
    if the object&rsquo;s attribute value is greater than the value
    specified in the condition) or a negation (an object satisfies a
    condition if the object&rsquo;s attribute value does not match the
    value specified in the condition.) -->
    </para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>autocorrelation</glossterm>
  <glossdef>
    <para>For relational data, we define
          autocorrelation (C') to be the correlation between the same
          attribute on distinct objects belonging to the same set. For
          example, we can compute the autocorrelation of gross
          receipts for movies having the same producer.  If all values
          of the attribute are the same, C'=1. If the attribute values
          are independent, C'=0.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>bias</glossterm>
  <glossdef>
    <para>Bias is the systematic difference between the values
    predicted by the learned model and actual values.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>binary classification problem</glossterm>
  <glossdef>
    <para>A classification task that assigns items to a class or its
    complement.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>boundary edge</glossterm>
  <glossdef>
    <para>A boundary edge is a query edge that crosses a subquery box.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>boundary vertex</glossterm>
  <glossdef>
    <para>A boundary vertex is a vertex within a subquery box that is
    connected to query elements outside the subquery box by a
    boundary edge.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>bounded range</glossterm>
  <glossdef>
    <para>A numeric annotation of the form
    [<replaceable>i</replaceable>..<replaceable>j</replaceable>], a
    bounded range specifies that there must be at least
    <replaceable>i</replaceable> and no more than
    <replaceable>j</replaceable> corresponding elements to match the
    query.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>classifier</glossterm>
  <glossdef>
    <para>A classifier is a model that predicts the value of a class
    label based on the values of other variables.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>class label</glossterm>
  <glossdef>
    <para>The class label is an attribute of an item (object or link)
    that serves to classify the item into one of a number of distinct
    categories. Classification models, such as those in Proximity,
    seek to predict the class label.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>clustering coefficient</glossterm>
  <glossdef>
    <para>A measure of the interrelatedness a node&rsquo;s neighbors, the
    clustering coefficient is the fraction of existing links connecting
    a node&rsquo;s neighbors to each other out of the maximum possible
    number of such links.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>collective classification</glossterm>
  <glossdef>
    <para>Collective classification makes simultaneous statistical
    judgments about the same set of variables for a set of related data
    instances using an iterative process.  Predictions about each
    variable are used to inform predictions for the remaining
    variables during each iteration.</para> 
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>comparable types</glossterm>
  <glossdef>
    <para>Conditions and constraints can compare attribute values of
    the same type (e.g., <literal>STR</literal> with
    <literal>STR</literal>).  In addition, you can compare attributes
    of type  <literal>DBL</literal> with <literal>FLT</literal> and
    <literal>INT</literal>, and attributes of type
    <literal>FLT</literal> with <literal>INT</literal>.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>complex condition</glossterm>
  <glossdef>
    <para>In principle, a complex condition can be any boolean
    combination of simple conditions. Proximity&rsquo;s implementation
    of QGraph restricts complex conditions to disjunctive normal
    form.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>condition</glossterm>
  <glossdef>
    <para>A condition restricts query matches by requiring that
    database items match specified attribute values.  For example, the
    condition <token role="cond">ObjType&nbsp;=&nbsp;person</token> on
    a vertex requires that that vertex only match objects with a
    <token role="attr">ObjType</token> attribute having a value of
    <token role="attr">person</token>.  Existence conditions work
    similarly, but only require that the corresponding object or link
    have <emphasis>any</emphasis> value for the specified attribute
    without caring what that value is.</para>
  </glossdef>
</glossentry>

<!--
<glossentry>
  <glossterm>conditional log likelihood</glossterm>
  <glossdef>
    <para>TBD; "evaluation of the log-likelihood function is
    conditioned on a set of pre-sample observations"</para>
  </glossdef>
</glossentry>
-->

<glossentry>
  <glossterm>conditional probability distribution</glossterm>
  <glossdef>
    <para>The conditional probability measures the likelihood that one
    event <varname>X</varname> has occurred given the knowledge that
    another event <varname>Y</varname> has occurred, usually stated
    as the probability of <varname>X</varname>
    <emphasis>given</emphasis> <varname>Y</varname>.
    The conditional probability distribution provides the
    distribution of probabilities for <varname>X</varname> given
    <varname>Y</varname>. That is, it is the collection of probability
    distributions of <varname>X</varname> given that
    <varname>Y</varname> assumes a value <varname>y</varname>, for each
    such value of <varname>Y</varname>.
    <!-- In the discrete case, if 
    <varname>X</varname> can assume two distinct values, &x1; and
    &x2;, and <varname>Y</varname> can assume three distinct values,
    &y1;, &y2;, and &y3;, then the conditional probability
    distribution of <varname>X</varname> given <varname>Y</varname> is
    the series of values for the probabilities 
    of &x1; given &y1;, &x1; given &y2;, &x1; given &y3;, &x2; given
    &y1;, &x2; given &y2; and &x2; given &y3;.  -->
    </para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>connected components</glossterm>
  <glossdef>
    <para>Two vertices in a graph are in the same connected component
    if and only if there is a path from one vertex to the other.  A
    connected component is thus a subgraph that contains a path 
    between all pairs of vertices in the subgraph.  Link direction is
    ignored in Proximity&rsquo;s implementation of the connected
    components algorithm.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>constraint</glossterm>
  <glossdef>
    <para>Constraints compare the attribute values or identities of two
    distinct query elements.
    Only pairs of objects or links that satisfy the constraint match
    the corresponding query.</para> 
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>container</glossterm>
  <glossdef>
    <para>A container is a collection of subgraphs usually created as
    the result of executing a query.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>core vertex</glossterm>
  <glossdef>
    <para>The core vertex is the vertex from a QGraph query that
    corresponds to the object to be classified.  Objects and links
    connected to the core vertex define the <emphasis>local
    neighborhood</emphasis> to be
    used in classifying the core object.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>cross validation</glossterm>
  <glossdef>
    <para>Cross validation is the practice of partitioning the
    available data into multiple subsamples such that one
    or more of the subsamples is used to fit (train) a model, with the
    remaining subsamples being used to test how well the model
    performs.  Because the model is tested on data not used in
    training the model, cross validation can provide an useful
    estimate of how the model will perform on new data.
    In knowledge discovery, the process of cross validation is
    often repeated many times in order to compare different versions
    of the model (i.e., different values for a model&rsquo;s
    parameters) in order to select the highest-performing version.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>degree</glossterm>
  <glossdef>
    <para>The degree of a node in a graph is the count of edges
    connected to that node.  In directed graphs,
    <emphasis>in degree</emphasis> counts the number of edges pointing
    to the target node and <emphasis>out degree</emphasis> counts the
    number of edges pointing away from the target node.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>degree disparity</glossterm>
  <glossdef>
    <para>Degree disparity is difference in the number of items
          (links, objects, attributes, values) that varies
          systematically with the class label.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>dependency network</glossterm>
  <glossdef>
    <para>A dependency network is a graphical model that represents
    dependencies among variables.
    Dependency networks approximate the full joint probability
    distribution with a set of independently learned conditional probability
    distributions (one for each variable given its parents).
    Dependency networks admit simple techniques for parameter
    estimation and structure learning, even though, as an approximate
    model, they are not guaranteed to specify a coherent probability
    distribution for small samples.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>directed edge</glossterm>
  <glossdef>
    <para>A directed edge in a query requires matching links in the
    database follow the same direction as the query edge.</para>
  </glossdef>
</glossentry>

<!--
<glossentry>
  <glossterm>directedness</glossterm>
  <glossdef>
    <para>The directedness of an edge in a QGraph query determines
    whether it is directed (points from one vertex to another) or
    undirected (links two vertices without specifying a direction for
    that link.</para>
  </glossdef>
</glossentry>
-->

<glossentry>
  <glossterm>disconnected query</glossterm>
  <glossdef>
    <para>A query must be a single connected graph. A query containing
    more than one connected component is considered to be disconnected
    and thus not allowed.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>disjunctive normal form</glossterm>
  <glossdef>
    <para>Boolean formulae expressed as a disjunction of
    conjunctions are said to be in disjunctive normal form.  Such
    formulae consist of a series of disjunctions (expressions
    <literal>OR</literal>ed together) where each expression is either
    a terminal expression (a simple proposition in the case of boolean
    logic or a simple condition in the case of Proximity conditions),
    the negation of a terminal expression, or the conjunction
    (expressions <literal>AND</literal>ed together) of terminal
    expressions.
    </para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>document type definition</glossterm>
  <glossdef>
    <para>A document type definition (DTD) is a formal specification
    of the structure of an XML document. It specifies which XML
    elements and attributes may occur in which places in the
    document. An XML document is valid if it obeys the structure
    specified in the associated DTD.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>edge</glossterm>
  <glossdef>
    <para>Proximity uses the terms <wordasword>vertex</wordasword> and
    <wordasword>edge</wordasword> to refer to entities in a query
    and the terms <wordasword>object</wordasword> an
    <wordasword>link</wordasword> to refer to entities in the data. 
    An edge in a query matches corresponding links in the data.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>error cost</glossterm>
  <glossdef>
    <para>The cost assigned to an error can be broken down into
    positive error cost (the cost of a false positive) and
    negative error cost (the cost of a false negative).</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>exact annotation</glossterm>
  <glossdef>
    <para>An exact annotation requires a specific number of matches
    for example, [2], rather than a range in the number of matches
    such as [2-4] or [2..].</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>existence condition</glossterm>
  <glossdef>
    <para>Existence conditions check to see if the
    corresponding object or link has a value for the specified
    attribute. An existence condition is satisfied if the
    corresponding item has any value for the attribute, regardless
    of what that value is.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>feature</glossterm>
  <glossdef>
    <para>An attribute provides us with information on the
    characteristics of an entity. A feature tells us which
    (aggregated) values of
    an attribute are useful for determining membership in a class.
    For example, links from actor objects to movie objects might have
    an attribute that records the salary earned by that actor for
    that movie.  A feature of a model that estimates the
    likelihood of a particular movie winning a major award might
    require that the combined salary for its actors be above a
    specified threshold.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>filter</glossterm>
  <glossdef>
    <para>A filter restricts a set of objects or links displayed in
    the Proximity Database Browser to those that have a specified
    attribute value. For example, you can filter objects in the
    ProxWebKB database by 
    <token role="attr">pagetype</token> such that only objects having
    the specified <token role="attr">pagetype</token> are shown.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>forest fire graph</glossterm>
  <glossdef>
    <para>Forest fire graphs <xref linkend="leskovec05"/>
    are a type of synthetic graph that exhibit small-world
    characteristics (low diameter, power law degree distribution, high
    clustering coefficient).  The name stems from the way the model
    creates edges for new nodes by spreading ("burning") connections
    via existing links in the graph.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>Gibbs sampling</glossterm>
  <glossdef>
    <para>Gibbs sampling is used to generate samples from the joint probability
    distribution of two or more variables when the conditional
    probability distribution of those variables is known.
    The algorithm initializes each variable to a random value and then
    iterates over all variables, assigning a revised value for that
    variable conditioned on the current values of the other
    variables. The process of revising these values is repeated
    hundreds or thousands of times, using the previous values as the
    new initial values.  An initial &ldquo;burn-in&rdquo;
    period of a pre-determined number of iterations is typically
    required in order to avoid transient effects due to the initial
    conditions.</para>
  </glossdef>
</glossentry>

<!--
<glossentry>
  <glossterm>graph database</glossterm>
  <glossdef>
    <para>A graph database represents data as a graph of vertices
    corresponding to &ldquo;things&rsquo; in the database and edges
    corresonding to the connections among those things.</para>
  </glossdef>
</glossentry>
-->

<glossentry>
  <glossterm>hubs and authorities</glossterm>
  <glossdef>
    <para>Hubs and authorities is the name
    commonly given to an algorithm developed by Jon Kleinberg to aid
    in the structural analysis of the World Wide Web.  The algorithm
    uses link structure to identify objects in a graph (e.g.,&nbsp;web
    pages) likely to be trusted sources of information (authorities)
    and objects that are likely to link to many related authorities
    (hubs).  Although originally designed with web search in mind, the
    hubs and authorities algorithm has found wide use in other domains
    requiring the analysis of network structures.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>identity constraint</glossterm>
  <glossdef>
    <para>Identity constraints compare the identity (OID) of two
    database entities.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>independent and identically distributed</glossterm>
  <acronym>i.i.d.</acronym>
  <glossdef>
    <para>Values are independent and identically distributed if they
    come from the same probability distribution and they have been
    independently sampled from that distribution (the values are
    statistically independent).</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>infix notation</glossterm>
  <glossdef>
    <para>Prefix notation places an expression&rsquo;s operator between
    its operands.  For example, the expression
    <varname>a</varname>&nbsp;+&nbsp;<varname>b</varname> uses infix
    notation.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>initialization</glossterm>
  <glossdef>
    <para>New Proximity databases must be initialized before importing
    data.  Initialization creates the MonetDB tables required by
    Proximity&rsquo;s data schema.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>inner structure</glossterm>
  <glossdef>
    <para>The inner structure of a subquery is the set of vertices and
    edges that fall entirely within the subquery box.  The boundary
    edge and subquery annotation are not part of the inner
    structure.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>input source</glossterm>
  <glossdef>
    <para>Input sources define the pieces of information (attribute
    values and graph structure characteristics) that a model may use
    to predict class labels.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>instantiation</glossterm>
  <glossdef>
    <para>Instantiating a Proximity model creates a new instance of
    the model using the specified or default values for the model&rsquo;s
    parameters.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>isomorphic</glossterm>
  <glossdef>
    <para>Isomorphic subgraphs have the same structure in terms of
    nodes and edges but may have different member objects and
    links.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>joint probability distribution</glossterm>
  <glossdef>
    <para>The joint probability measures the likelihood
    of two or more events occurring together, usually stated as the
    probability of <varname>X</varname> <emphasis>and</emphasis>
    <varname>Y</varname>.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>knowledge discovery</glossterm>
  <glossdef>
    <para>Knowledge discovery seeks to find useful patterns in
    large and complex databases.
    More specifically, relational knowledge discovery focuses on
    constructing useful statistical models from data about complex
    relationships among people, places, things, and events.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>label</glossterm>
  <glossdef>
    <para>See <wordasword>name</wordasword>.</para>
  </glossdef>
</glossentry>

<!--
<glossentry>
  <glossterm>Laplace correction</glossterm>
  <glossdef>
    <para>Laplace correction is a smoothing technique often used on
    probability estimates based on small samples. The correction
    biases the estimates away from extreme values and towards a more
    uniform distribution.</para> 
  </glossdef>
</glossentry>
-->

<glossentry>
  <glossterm>lattice graph</glossterm>
  <glossdef>
    <para>A lattice graph arranges vertices and edges in a
    periodic pattern yielding a regular graph structure.</para>
  </glossdef>
</glossentry>

<!--
<glossentry>
  <glossterm>likelihood</glossterm>
  <glossdef>
    <para>A likelihood function can be thought of as the reverse of
    traditional conditional probability functions. Rather than
    estimating the probability of a particular outcome based on known
    parameters, likelihood functions are used to determine unknown
    parameters based on known outcomes.  For example, given the 
    observation that the probability of seeing two heads in two
    consecutive coin tosses is 0.25, the parameter to be estimated is
    the probability of seeing a head on a single toss, i.e., p(head).
    </para>
  </glossdef>
</glossentry>
-->

<glossentry id="gloss_link">
  <glossterm>link</glossterm>
  <glossdef>
    <para>A link is a directed binary relation connecting two objects
    in a Proximity database.  We use <wordasword>link</wordasword> to
    refer to relations in a database and <wordasword>edge</wordasword>
    to refer to relations in a query.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>link specification</glossterm>
  <glossdef><para>A link specification describes how to add new links
  to a database using a query. The specification identifies the query
  vertices that correspond to the new links&rsquo; starting and ending
  objects and may provide attribute values for the new links.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>loop</glossterm>
  <glossdef>
    <para>see <wordasword>self link</wordasword></para>
  </glossdef>
</glossentry>

<!--
<glossentry>
  <glossterm>MIL</glossterm>
  <glossdef>
    <para>Monet interpreter language</para>
  </glossdef>
</glossentry>
-->

<glossentry>
  <glossterm>mirror match</glossterm>
  <glossdef>
    <para>A mirror match to a QGraph query is a pair of otherwise
    identical subgraphs that differ only in terms of how the
    subgraph&rsquo;s objects and links match the query&rsquo;s
    vertices and edges. Specifically, in a mirror match, two objects
    reverse positions from their original locations in the other
    matching subgraph.</para>
  </glossdef>
</glossentry>

<!--
<glossentry>
  <glossterm>model</glossterm>
  <glossdef>
    <para>A model is a hypothetical description of a real-world
    process.</para>
  </glossdef>
</glossentry>
-->

<glossentry>
  <glossterm>multi-dimensional attribute</glossterm>
  <glossdef>
    <para>A multi-dimensional (or multi-column) attribute in Proximity
    contains more than one value.  For example, a
    <token role="attr">location</token> attribute might contain two
    values corresponding to the <varname>x</varname> and
    <varname>y</varname> coordinates of the item&rsquo;s position.
    Proximity permits the inclusion of multi-dimensional
    attributes in data but does not yet support their use in queries
    or models.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>name</glossterm>
  <glossdef>
    <para>Each vertex and edge in a Proximity query is assigned a name
    (label) that is used to identify the corresponding items in the
    matching subgraphs.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>negated element</glossterm>
  <glossdef>
    <para>A negated query element (vertex or edge) has a numeric
    annotation of <literal>[0]</literal>; there must be no
    corresponding element in the data when matching the query.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>negative instance</glossterm>
  <glossdef>
    <para>A negative instance is a member of the training set that is
    not a member of the target class.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>nested synchronized table</glossterm>
  <glossdef>
    <para>A nested synchronized table (NST) is an internal Proximity
    data structure that provides a more user-friendly view of the
    corresponding MonetDB tables.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>numeric annotation</glossterm>
  <glossdef>
    <para>Numeric annotations place limits on the number of isomorphic
    substructures that can occur in matching portions of the
    database. Annotations also serve to group isomorphic structures
    into a single subgraph rather than producing multiple matches.</para>
  </glossdef>
</glossentry>

<glossentry id="gloss_object">
  <glossterm>object</glossterm>
  <glossdef>
    <para>An object is a Proximity database entity that represents
    things in the world such as people, places, and events.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>object identifier</glossterm>
  <glossdef>
    <para>The object identifier (OID) is an internal identifier for an
    object or link in MonetDB.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>optional element</glossterm>
  <glossdef>
    <para>Optional query elements define structures that can be, but
    are not required to be present in the data in order to match the
    query.  They are annotated with
    <token role="annot">[0..<replaceable>n</replaceable>]</token>
    or <token role="annot">[0..]</token>.</para>
  </glossdef>
</glossentry>

<!--
<glossentry>
  <glossterm>parameter estimation</glossterm>
  <glossdef>
    <para>Parameter estimation identifies the specific values of the
    variables in a model, such as the threshold values in a
    probability estimation tree.</para>
  </glossdef>
</glossentry>
-->

<glossentry>
  <glossterm>positive instance</glossterm>
  <glossdef>
    <para>A positive instance is a member of the training set that is
    a member of the target class.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>precedence</glossterm>
  <glossdef>
    <para>Precedence determines the order in which query elements are
    considered in matching the database.  An annotated vertex has
    precedence over an annotated edge because the match process first
    finds objects that match the annotated vertex and then finds links
    from that object to match the corresponding edges in the query.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>prefix notation</glossterm>
  <glossdef>
    <para>Prefix notation places an expression&rsquo;s operator before
    its operands.  For example, the expression
    <varname>a</varname>&nbsp;+&nbsp;<varname>b</varname> becomes
    +&nbsp;<varname>a</varname>&nbsp;<varname>b</varname> when using
    prefix notation.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>prior probability distribution</glossterm>
  <glossdef>
    <para>The prior probability distribution of a variable provides
    the probability distribution of that variable&rsquo;s values in the
    absence of other evidence.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>probabilistic model</glossterm>
  <glossdef>
    <para>A probabilistic model assigns a probability to each
    potential outcome such that the sum of all the probabilities (all
    the outcomes) equals 1.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>probability estimation tree</glossterm>
  <glossdef>
    <para>Probability estimation trees recursively partition the
    sample space. The results are represented as a graph (tree) where
    nodes are branch points corresponding to variables and arcs to
    child nodes correspond to features (specific values for that
    variable). Leaf nodes estimate the predicted value of an input
    instance.  Advantages of probability estimation trees include ease
    of understanding and the ability to handle different types of
    variables.</para> 
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>propositionalizing data</glossterm>
  <glossdef>
    <para>Propositionalizing data &ldquo;flattens&rdquo; relational
    data by moving attributes of related items to the objects of
    interest. For example, in a system that reasons about movies,
    propositionalizing an attribute of a director, such as  
    <token role="attr">date-of-birth</token>, might place that
    attribute on related movie objects as
    <token role="attr">director-date-of-birth</token>.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>proxy node</glossterm>
  <glossdef>
    <para>To avoid cluttering the display with too many objects, the
    graphical database browser expands objects incrementally, using
    proxy nodes to represents additional objects not yet shown in the
    graph. Clicking a proxy node adds additional objects to the
    display.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>pseudolikelihood</glossterm>
  <glossdef>
    <para>Pseudolikelihood approximates the distribution of a
    random variable using an &ldquo;intuitively plausible&rdquo;
    function. It is used when standard calculations of 
    likelihood are intractable.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>QGraph</glossterm>
  <glossdef>
    <para>QGraph is a visual query language designed to support
    knowledge discovery in large graph databases.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>query</glossterm>
  <glossdef>
    <para>A QGraph query is a labeled, connected graph depicting the
    target structure (objects and links) to be matched. Additional query
    features refine the desired match by specifying required attribute
    values, constraining the relationships among query elements, and
    limiting the number of data elements that may match specific query
    components.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>relational Bayesian classifier</glossterm>
  <glossdef>
    <para>The relational Bayesian classifier (RBC) is a modification
    of the simple Bayesian classifier for relational data.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>relational data</glossterm>
  <glossdef>
    <para>As used in this document, relational data refers
          to data that explicitly represent relations among
          objects as first-class entities.  Relational data
          are represented by a directed graph in which nodes
          represent objects from the domain of interest and links
          represent relationships between pairs of objects.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>relational dependency network</glossterm>
  <glossdef>
    <para>A relational dependency network (RDN) is a graphical model
    that extends dependency networks for relational data.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>relational probability tree</glossterm>
  <glossdef>
    <para>A relational probability tree (RPT) is an extension of
    standard probability estimation trees for relational data.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>root container</glossterm>
  <glossdef>
    <para>The root container in Proximity serves as a virtual
    &ldquo;parent&rdquo; container for other Proximity containers.
    It does not explicitly exist in the database and thus cannot be
    deleted or queried itself.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>sampling</glossterm>
  <glossdef>
    <para>Sampling extracts a portion of a data set for use in
    learning or testing a model.  Sampling typically uses random or
    systematic selection so as to create a set that is representative
    of the larger population.  Alternately, sampling can use natural
    divisions in the data (e.g., temporal sampling) to create the
    samples.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>schema</glossterm>
  <glossdef>
    <para>A database&rsquo;s schema determines how the data are
    represented, i.e., which data entities are mapped to objects,
    which are mapped to links, and what constitutes
    attributes of those objects and links. Proximity also uses an
    internal schema that determines how Proximity database structures
    map to MonetDB data structures.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>schema analysis</glossterm>
  <glossdef>
    <para>Schema analysis discovers how a database&rsquo;s attributes
    map to object and link types, and which types of objects are
    connected by each link type.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>self link</glossterm>
  <glossdef>
    <para>A self-link connects a node with itself. For example, web
    pages often contain hyperlinks that jump to another part of the
    current page, linking the web page to itself.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>social network analysis</glossterm>
  <glossdef>
    <para>A social network models the relationships among members in a
    social group.  The analysis of social networks is concerned with
    the development and computation of indices that attempt to measure
    local and global characteristics of the network, such as measures
    of centrality (the relative structural importance of a node in the
    graph).</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>star query</glossterm>
  <glossdef>
    <para>A one-dimensional star query includes a <emphasis>core
    vertex</emphasis> and one or more neighboring vertices, each
    connected to the core vertex by a single edge.  Typically, the
    neighboring vertices (and therefore the corresponding edges as
    well) are annotated with an unbounded range, permitting any number
    of matching neighbor objects and links.  Star queries can be extended to
    additional dimensions through the use of subqueries.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>statistical independence</glossterm>
  <glossdef>
    <para>Two events are statistically independent when the occurrence
    (or lack thereof) of one event does not change the probability of
    the other event occurring.  More particularly for this document, 
    statistical independence means that knowing whether the first
    event occurs does not affect our ability to predict whether the
    second event occurs.</para>
  </glossdef>
</glossentry>

<!--
<glossentry>
  <glossterm>structure learning</glossterm>
  <glossdef>
    <para>Structure learning finds the specific form of a model that
    best fits the input data.  For predictive models, structure
    learning identifies the dependencies among the variables.
    Structure learning goes hand-in-hand with parameter estimation,
    which identifies the values for those variables (e.g., the
    strength of those dependencies).</para>
  </glossdef>
</glossentry>
-->

<glossentry>
  <glossterm>subgraph</glossterm>
  <glossdef>
    <para>A subgraph is a connected portion of a graph.  QGraph
    queries return subgraphs as matches to the query.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>subquery</glossterm>
  <glossdef>
    <para>A subquery is a connected subgraph of vertices and edges
    that can be treated as a logical unit.  Subqueries allow grouping
    and limiting of complex query structures rather than just
    individual query elements.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>temporal attribute</glossterm>
  <glossdef>
    <para>Generally speaking, a temporal attribute captures some
    characteristic of the target entity that includes a temporal
    component, such as the time an event occurred or a temporal
    interval during which the characteristic holds.
    Temporal attributes in Proximity take the form of an
    attribute that specifies a single time stamp associated with the
    corresponding object or link, such as a 
    <token role="attr">date-of-birth</token> attribute on a 
    <token role="object">person</token> object.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>test set</glossterm>
  <glossdef>
    <para>A test set is a labeled data set or sample set aside to
    test classifier performance after training.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>training set</glossterm>
  <glossdef>
    <para>A training set is a set of labeled instances used to learn a
    model.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>type</glossterm>
  <glossdef>
    <para>A type is a label that categorizes instances in a
    data set, usually represented as an attribute-value pair assigned
    to an object or link.  For example, a data set might contain
    objects that represent three types of entities: actors, movies, and
    studios.
    Proximity does not require a type attribute, but users may specify
    zero, one, or many attributes that provide type information. These
    attributes can be practical for the user, but in fact Proximity
    does not distinguish attributes representing type information from
    attributes representing other kinds of information.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>unbounded range</glossterm>
  <glossdef>
    <para>A numeric annotation of the form
    [<replaceable>i</replaceable>..], an unbounded range 
    specifies that there must be at least <replaceable>i</replaceable>
    corresponding element(s) to match the query.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>undirected edge</glossterm>
  <glossdef>
    <para>An undirected edge in a query matches links in the database
    regardless of the link&rsquo;s direction.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>update query</glossterm>
  <glossdef>
    <para>An update query modifies (updates) the database by adding or
    removing objects, links, or attributes.  The QGraph language
    provides full update functionality; however, only a portion of
    that functionality has been implemented in Proximity.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>validation</glossterm>
  <glossdef>
    <para>Validation is the process of ensuring that an XML document
    obeys the structure specified in the associated DTD. In Proximity,
    queries (which are represented internally in XML) must validate
    against the DTD in <filename>graph-query.dtd</filename>. Because
    DTDs cannot specify semantic content or enforce all
    potential syntactic requirements, a syntactically valid query may
    still be illegal under the rules of QGraph.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>vertex</glossterm>
  <glossdef>
    <para>Proximity uses the terms <wordasword>vertex</wordasword> and
    <wordasword>edge</wordasword> to refer to entities in a query
    and the terms <wordasword>object</wordasword> an
    <wordasword>link</wordasword> to refer to entities in the data. 
    A vertex in a query matches corresponding objects in the data.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>vertical database</glossterm>
  <glossdef>
    <para>A vertical (or vertically fragmented) database, such as
    MonetDB, employs a storage model based on vertical decomposition,
    which stores the attribute values for a single object across
    multiple tables.</para>
  </glossdef>
</glossentry>

<glossentry>
  <glossterm>well formed</glossterm>
  <glossdef>
    <para>A well-formed query conforms to all rules governing how
    queries may be legally structured.</para>
  </glossdef>
</glossentry>

</glossary>

<!--
  Local Variables:
  mode: sgml
  sgml-set-face: t
  sgml-indent-step: nil
  sgml-always-quote-attributes: t
  sgml-parent-document: ("user/tutorial/Tutorial.xml" "book" "glossary")
  sgml-default-dtd-file:"DocBook.ced"
  End:
-->
