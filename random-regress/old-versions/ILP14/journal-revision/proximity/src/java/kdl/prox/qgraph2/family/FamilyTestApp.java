/**
 * $Id: FamilyTestApp.java 3658 2007-10-15 16:29:11Z schapira $
 *
 * Part of the open-source Proximity system
 *   (see LICENSE for copyright and license information).
 *
 */

/**
 * $Id: FamilyTestApp.java 3658 2007-10-15 16:29:11Z schapira $
 */

package kdl.prox.qgraph2.family;

import kdl.prox.app.ImportAsciiGraph;
import kdl.prox.db.Attributes;
import kdl.prox.db.DB;
import kdl.prox.util.Assert;
import org.apache.log4j.Logger;

import java.io.*;
import java.util.*;


/**
 * Class that runs a query family test, as generated by QueryGenApp and
 * filled-in by test writers. Recall the overall process :
 * <p/>
 * 1. make '<family name>.fam.xml' (1)
 * 2. run QueryGenApp              (creates N 'query_<description>.xml' files)
 * 3. edit '<family name>.fam.dat' (1)
 * 4. edit 'query_<description>.mat'      (N)
 * 5. run FamilyTestApp
 * <p/>
 * <p/>
 * Specfically, this class is passed a queryFamilyDirName, which must contain
 * a) the query instances created by QueryGenApp ('query_<description>.xml'),
 * and b) the filled-in .dat and .mat files ('<family name>.fam.dat' and
 * 'query_<description>.mat').
 * <p/>
 * The class also receives an implementation of a QueryTester, which specifies how to test each query
 * For example. the QgraphQueryTester implementation tests all possible paths in the TFM graph.
 * <p/>
 * The family is tested in this way:
 * <p/>
 * 1. empty and reinitialize the database specified by configFile
 * 2. populate the database using '<family name>.fam.dat' file
 * 3. test each 'query_<description>.xml' file,
 * 4. log test results, incl. ea. test's success and transformation usage distribution
 * <p/>
 * <p/>
 * There is also a testAllFamilies method, which takes a directory and recursively
 * calls testFamily on all its children
 */
public class FamilyTestApp {

    private static Logger log = Logger.getLogger(FamilyTestApp.class);


    public static List<QueryTestFailure> testAllFamilies(String queryFamiliesDirName, QueryTester qt) {
        Assert.notNull(queryFamiliesDirName, "queryFamiliesDirName null");

        // validate parameters
        File queryFamiliesDir = new File(queryFamiliesDirName);
        if (!queryFamiliesDir.exists()) {
            log.fatal("query family directory not found: " + queryFamiliesDir);
            return new ArrayList<QueryTestFailure>();
        }

        // Go through the list of subdirectories, for each family,
        // and create a familiTestApp object to test the family
        // and collect the results in failureList.
        // Families are identified because their directories start with family_
        log.info("* starting query families test: " + queryFamiliesDir);
        List<QueryTestFailure> failureList = new ArrayList<QueryTestFailure>();
        FilenameFilter familyDirFilter = new FilenameFilter() {
            public boolean accept(File dir, String name) {
                return name.startsWith("family_");
            }
        };
        File[] familyDirs = queryFamiliesDir.listFiles(familyDirFilter);
        for (int fileIndex = 0; fileIndex < familyDirs.length; fileIndex++) {
            File familyDir = familyDirs[fileIndex];
            log.info("  testing family: " + familyDir);
            List familyFailures = testFamily(familyDir.toString(), qt);
            failureList.addAll(familyFailures);
            if (familyFailures.size() != 0) {
                log.info("  failures: " + familyFailures);
            } else {
                log.info("  no failures");
            }
        }

        return failureList;
    }

    public static List<QueryTestFailure> testFamily(String familyDirName, QueryTester qt) {
        Assert.notNull(familyDirName, "familyDirName null");
        Assert.notNull(qt, "queryTester null");

        // validate parameters
        File queryFamilyDir = new File(familyDirName);
        if (!queryFamilyDir.exists()) {
            log.fatal("query family directory not found: " + queryFamilyDir);
            return new ArrayList<QueryTestFailure>();
        }

        // collect inputs, do the work
        log.info("* starting query family test: " + queryFamilyDir);
        List<QueryTestFailure> failureList = new ArrayList<QueryTestFailure>();
        try {
            // populate db with fam.dat file
            String nicknameAttrName = "objectAlias";
            File famDatFile = famDatFile(queryFamilyDir);
            Map queryDataPairMap = queryDataPairs(queryFamilyDir);
            Assert.condition(queryDataPairMap.size() != 0, "no query/data files to test");   /** todo throw better exception? */
            log.warn("* clearing database '" + DB.description() + "'!");
            DB.clearDB();
            DB.initEmptyDB();   /** todo get confirmation to continue/clear (or delay with time to cancel)? */
            defineTestSchema(nicknameAttrName);
            populateDB(famDatFile, nicknameAttrName);

            // test queries against their .mat files
            String familyName = queryFamilyDir.getName();
            log.info("* testing " + queryDataPairMap.size() + " queries");
            Iterator queryDataPairIter = queryDataPairMap.values().iterator();
            while (queryDataPairIter.hasNext()) {
                QueryDataPair queryDataPair = (QueryDataPair) queryDataPairIter.next();
                try {
                    log.info("* testing query: " + queryDataPair.getDescription());
                    Assert.condition((queryDataPair.getMatFile() != null) &&
                            (queryDataPair.getQueryFile() != null), "empty mat or query file: " +
                            queryDataPair);
                    failureList.addAll(qt.testQuery(queryDataPair, familyName));
                } catch (Exception exc) {
                    String msg = "exception testing query " +
                            queryDataPair.getQueryFile() + ":" + exc;
                    QueryTestFailure thisFailure = new QueryTestFailure(familyDirName, null, null, msg);
                    failureList.add(thisFailure);
                    log.error(msg);
                }
            }

            // todo log test results, incl. ea. test's success and transformation usage distribution
            log.info("* query family test done");
        } catch (Exception exc) {
            String msg = "error testing family: " + exc;
            QueryTestFailure thisFailure = new QueryTestFailure(familyDirName, null, null, msg);
            failureList.add(thisFailure);
            log.error(msg);
        }

        return failureList;
    }


    /**
     * Called by constructor, defines the attributes and collection(s) needed
     * for testing. Called after the database has been cleared.
     * <p/>
     * Attributes:
     * o linkName (L)      : link names from fam.dat file
     * o linkType (L)      : auto-generated link types based on link names
     * o objectName (O)    : object names from fam.dat file. aka 'nickname' attribute
     * o objectType (O)    : auto-generated object types based on link names
     * <p/>
     * Collections:
     * o family-data       : holds smart ASCII evaluation result
     *
     * @param nickNameAttr
     * @
     */
    private static void defineTestSchema(String nickNameAttr) {
        Attributes objAttrs = DB.getObjectAttrs();
        Attributes linkAttrs = DB.getLinkAttrs();
        objAttrs.defineAttribute(nickNameAttr, "str");
        objAttrs.defineAttribute("objectName", "str");
        objAttrs.defineAttribute("objectType", "str");
        linkAttrs.defineAttribute("linkName", "str");
        linkAttrs.defineAttribute("linkType", "str");
    }


    /**
     * Called by constructor, returns the '<family name>.fam.dat' file in
     * queryFamilyDir. For now simply gets all '*.fam.dat' files and errors if
     * not exactly one of them. Returns the one o/w.
     *
     * @param queryFamilyDir
     * @return
     * @throws FileNotFoundException
     */
    private static File famDatFile(File queryFamilyDir) throws FileNotFoundException {
        FilenameFilter famDatFilter = new FilenameFilter() {
            public boolean accept(File dir, String name) {
                return name.endsWith(".fam.dat");
            }
        };
        File[] datFiles = queryFamilyDir.listFiles(famDatFilter);
        if (datFiles.length != 1) {
            throw new FileNotFoundException("no '<family name>.fam.dat' file " +
                    "found in '" + queryFamilyDir + "'");
        } else {
            return datFiles[0];
        }
    }


    /**
     * Called by populateDB(), returns a List of one or three strings,
     * containing either an object (e.g., "a1"), or o1 link o2 (e.g.,
     * "a1 y2 b3"). Does no checking of line.
     *
     * @param line
     * @return
     */
    private static List itemTokensFromLine(String line) {
        List tokenList = new ArrayList();   // return value. filled next
        StringTokenizer stringTokenizer = new StringTokenizer(line);
        while (stringTokenizer.hasMoreTokens()) {
            tokenList.add(stringTokenizer.nextToken());
        }
        return tokenList;
    }


    /**
     * Called by constructor, populates proxDB with data from famDatFile. Recall
     * the format of famDatFile:
     * <p/>
     * a1
     * a2 x1 b1
     * a2 x2 b1
     * a3 x3 b2
     * ...
     * <p/>
     * You can see that each row contains either a single object or (more
     * commonly) a single edge with its o1 object listed to its left and its o2
     * object listed to its right(i.e., the edge goes from the left object to
     * the right one). To simplify creating test data and matches, we will use
     * a fixed schema for types and attributes:
     * <p/>
     * o link type attribute   : 'linkType'
     * o object type attribute : 'objectType'
     * <p/>
     * o link name attribute   : 'linkName'
     * o object name attribute : 'objectName'      <- todo reduntant with nickname
     * <p/>
     * o link types   : 'W', 'X', 'Y', 'Z'
     * o object types : 'A', 'B', 'C', 'D'
     * <p/>
     * o link names   : <w|x|y|z><N>, where n >= 0, i.e, w0, y33
     * o object names : <a|b|c|d><N>, where n >= 0, i.e, a0, c22
     *
     * @param famDatFile
     * @throws Exception
     */
    private static void populateDB(File famDatFile, String nicknameAttrName) throws Exception {
        // for each row in the file create a single object, or (more commonly)
        // a link and the two objects at either end. to aid processing we
        // collect from famDatFile a) a Set of unique object names, and b) a
        // Map from unique link names to an array of the link's o1 and o2 object
        // names (StringS) in that order
        Set objectNames = new HashSet();        // filled next.
        Map linkObjectMap = new HashMap();      // ""
        BufferedReader buffReader = null;       // set next. null if not set
        try {

            // fill objectNames and linkObjectMap
            buffReader = new BufferedReader(new FileReader(famDatFile));
            for (String line = buffReader.readLine(); line != null;
                 line = buffReader.readLine()) {
                List tokens = itemTokensFromLine(line);
                if (tokens.size() == 1) {           // have an object with no links
                    String objName = (String) tokens.get(0);
                    objectNames.add(objName);
                } else if (tokens.size() == 3) {    // have a link
                    String o1Name = (String) tokens.get(0);
                    String linkName = (String) tokens.get(1);
                    String o2Name = (String) tokens.get(2);
                    Object existingLink = linkObjectMap.get(linkName);
                    Assert.condition(existingLink == null, "link name not new: " +
                            linkName);
                    // Add the two objects to objectNames
                    objectNames.add(o1Name);
                    objectNames.add(o2Name);
                    linkObjectMap.put(linkName, new String[]{o1Name, o2Name});
                } else {
                    throw new IllegalArgumentException("line contained " +
                            "neither 1 nor 3 tokens: " + line + " -> " + tokens);
                }
            }

            // generate graph smart ASCII from objectNames and linkObjectMap. we
            // do so in two phases: 1) add object definitions from objectNames,
            // and 2) add link definitions from linkObjectMap
            StringBuffer smartAsciiSB = new StringBuffer();     // filled next

            Iterator objNameIter = objectNames.iterator();
            while (objNameIter.hasNext()) {
                String objName = (String) objNameIter.next();
                smartAsciiSB.append("* ");
                smartAsciiSB.append(objName);
                smartAsciiSB.append("\n");
                smartAsciiSB.append("objectName: ");    /** todo reduntant with nickname */
                smartAsciiSB.append(objName);
                smartAsciiSB.append("\n");
                smartAsciiSB.append("objectType: ");
                smartAsciiSB.append(upperFirstChar(objName));   // objectTypeFromName()
                smartAsciiSB.append("\n\n");
            }

            Iterator linkNameIter = linkObjectMap.keySet().iterator();
            while (linkNameIter.hasNext()) {
                String linkName = (String) linkNameIter.next();
                String[] o1O2Array = (String[]) linkObjectMap.get(linkName);
                String o1Name = o1O2Array[0];
                String o2Name = o1O2Array[1];

                smartAsciiSB.append("* ");
                smartAsciiSB.append(o1Name);
                smartAsciiSB.append("->");
                smartAsciiSB.append(o2Name);
                smartAsciiSB.append("\n");
                smartAsciiSB.append("linkName: ");
                smartAsciiSB.append(linkName);
                smartAsciiSB.append("\n");
                smartAsciiSB.append("linkType: ");
                smartAsciiSB.append(upperFirstChar(linkName));  // linkTypeFromName()
                smartAsciiSB.append("\n\n");
            }

            log.debug("SmartAscii database : \n" + smartAsciiSB.toString());
            StringReader saStringReader = new StringReader(smartAsciiSB.toString());
            BufferedReader bufferedReader = new BufferedReader(saStringReader);
            ImportAsciiGraph.doImport(bufferedReader, nicknameAttrName);

        } finally {
            if (buffReader != null) {
                try {
                    buffReader.close();
                } catch (Exception exc) {
                    // ignore
                }
            }
        }
    }


    /**
     * Called by constructor, returns a Map that maps query descriptions ->
     * QueryDataPairS for the paired 'query_<description>.xml' and
     * 'query_<description>.mat' files in queryFamilyDir.
     *
     * @param queryFamilyDir
     * @return
     */
    private static Map queryDataPairs(File queryFamilyDir) {
        final String fileNamePrefix = "query_";
        Map queryDataPairMap = new HashMap();       // return value. maps query description -> queryDataPair. filled next
        FilenameFilter queryFilter = new FilenameFilter() {
            public boolean accept(File dir, String name) {
                return name.startsWith(fileNamePrefix);
            }
        };
        File[] xmlOrDatFiles = queryFamilyDir.listFiles(queryFilter);
        for (int fileIndex = 0; fileIndex < xmlOrDatFiles.length; fileIndex++) {
            File xmlOrDatFile = xmlOrDatFiles[fileIndex];
            String xmlOrDatFileName = xmlOrDatFile.getName();
            boolean isXMLFile = xmlOrDatFileName.endsWith(".xml");
            boolean isMatFile = xmlOrDatFileName.endsWith(".mat");
            Assert.condition(isXMLFile || isMatFile, "'" + xmlOrDatFileName +
                    "' did not end with .xml or .mat");

            // get xmlOrDatFile's description
            int prefixIdx = xmlOrDatFileName.indexOf(fileNamePrefix);
            int lastDotIdx = xmlOrDatFileName.lastIndexOf(".");
            Assert.condition((prefixIdx != -1) && (lastDotIdx != -1), "either '" +
                    fileNamePrefix + "' or '.' was not found in xml or query " +
                    "file name: '" + xmlOrDatFileName);
            String descr = xmlOrDatFileName.substring(fileNamePrefix.length(),
                    lastDotIdx);

            // lookup description in queryDataPairMap, creating one or setting
            // as needed
            QueryDataPair queryDataPair = (QueryDataPair) queryDataPairMap.get(descr);
            if (queryDataPair == null) {
                queryDataPair = new QueryDataPair(descr, xmlOrDatFile, isXMLFile);
                queryDataPairMap.put(descr, queryDataPair);
            } else {    // queryDataPair != null
                if (isXMLFile) {
                    Assert.condition(queryDataPair.getQueryFile() == null,
                            "matching queryDataPair already has a query file for " +
                                    "the description: '" + descr + "' -> " + queryDataPair);
                    queryDataPair.setQueryFile(xmlOrDatFile);
                } else {
                    Assert.condition(queryDataPair.getMatFile() == null,
                            "matching queryDataPair already has a mat file for " +
                                    "the description: '" + descr + "' -> " + queryDataPair);
                    queryDataPair.setMatFile(xmlOrDatFile);
                }
            }
        }
        return queryDataPairMap;
    }


    /**
     * Utility called by populateDB(), returns a String containing the uppercase
     * version of the first char of string.
     *
     * @param string
     * @return
     */
    private static String upperFirstChar(String string) throws IllegalArgumentException {
        Assert.stringNotEmpty(string, "linkName null or empty");
        char firstChar = string.charAt(0);
        char upperFirstChar = Character.toUpperCase(firstChar);
        return new String(new char[]{upperFirstChar});   /** todo better way to convert char to String? */
    }

}
